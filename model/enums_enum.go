// Code generated by go-enum
// DO NOT EDIT!

package model

import (
	"fmt"
)

const (
	// LogLevelDEBUG is a LogLevel of type DEBUG
	LogLevelDEBUG LogLevel = iota
	// LogLevelINFO is a LogLevel of type INFO
	LogLevelINFO
	// LogLevelERROR is a LogLevel of type ERROR
	LogLevelERROR
	// LogLevelWARNING is a LogLevel of type WARNING
	LogLevelWARNING
	// LogLevelPANIC is a LogLevel of type PANIC
	LogLevelPANIC
)

const _LogLevelName = "DEBUGINFOERRORWARNINGPANIC"

var _LogLevelMap = map[LogLevel]string{
	0: _LogLevelName[0:5],
	1: _LogLevelName[5:9],
	2: _LogLevelName[9:14],
	3: _LogLevelName[14:21],
	4: _LogLevelName[21:26],
}

func (i LogLevel) String() string {
	if str, ok := _LogLevelMap[i]; ok {
		return str
	}
	return fmt.Sprintf("LogLevel(%d)", i)
}

var _LogLevelValue = map[string]LogLevel{
	_LogLevelName[0:5]:   0,
	_LogLevelName[5:9]:   1,
	_LogLevelName[9:14]:  2,
	_LogLevelName[14:21]: 3,
	_LogLevelName[21:26]: 4,
}

// ParseLogLevel attempts to convert a string to a LogLevel
func ParseLogLevel(name string) (LogLevel, error) {
	if x, ok := _LogLevelValue[name]; ok {
		return LogLevel(x), nil
	}
	return LogLevel(0), fmt.Errorf("%s is not a valid LogLevel", name)
}

const (
	// MeansureUnitMETERS is a MeansureUnit of type METERS
	MeansureUnitMETERS MeansureUnit = iota
	// MeansureUnitMILES is a MeansureUnit of type MILES
	MeansureUnitMILES
)

const _MeansureUnitName = "METERSMILES"

var _MeansureUnitMap = map[MeansureUnit]string{
	0: _MeansureUnitName[0:6],
	1: _MeansureUnitName[6:11],
}

func (i MeansureUnit) String() string {
	if str, ok := _MeansureUnitMap[i]; ok {
		return str
	}
	return fmt.Sprintf("MeansureUnit(%d)", i)
}

var _MeansureUnitValue = map[string]MeansureUnit{
	_MeansureUnitName[0:6]:  0,
	_MeansureUnitName[6:11]: 1,
}

// ParseMeansureUnit attempts to convert a string to a MeansureUnit
func ParseMeansureUnit(name string) (MeansureUnit, error) {
	if x, ok := _MeansureUnitValue[name]; ok {
		return MeansureUnit(x), nil
	}
	return MeansureUnit(0), fmt.Errorf("%s is not a valid MeansureUnit", name)
}

const (
	// RightsUSER is a Rights of type USER
	RightsUSER Rights = iota
	// RightsMODERATOR is a Rights of type MODERATOR
	RightsMODERATOR
	// RightsADMINISTRATOR is a Rights of type ADMINISTRATOR
	RightsADMINISTRATOR
	// RightsSUPER is a Rights of type SUPER
	RightsSUPER
	// RightsOWNER is a Rights of type OWNER
	RightsOWNER
)

const _RightsName = "USERMODERATORADMINISTRATORSUPEROWNER"

var _RightsMap = map[Rights]string{
	0: _RightsName[0:4],
	1: _RightsName[4:13],
	2: _RightsName[13:26],
	3: _RightsName[26:31],
	4: _RightsName[31:36],
}

func (i Rights) String() string {
	if str, ok := _RightsMap[i]; ok {
		return str
	}
	return fmt.Sprintf("Rights(%d)", i)
}

var _RightsValue = map[string]Rights{
	_RightsName[0:4]:   0,
	_RightsName[4:13]:  1,
	_RightsName[13:26]: 2,
	_RightsName[26:31]: 3,
	_RightsName[31:36]: 4,
}

// ParseRights attempts to convert a string to a Rights
func ParseRights(name string) (Rights, error) {
	if x, ok := _RightsValue[name]; ok {
		return Rights(x), nil
	}
	return Rights(0), fmt.Errorf("%s is not a valid Rights", name)
}
